/* p.160 */
/* 
    아스키코드 : 2진수와 영어/특수문자 교환하는 방식/규칙
        001 0001 <-------> A


        - 프로그래밍 언어들 마다 문자열 처리하는 방법이 다름(JS는 배열)    

    배열
        - 여러 자료를 묶어서 활용할 수 있는 특수한 자료
        - 왜?? 문자열과 배열은 똑같이 사용됨.
            -let 변수/상수 = [ ] // 배열 형태가 이렇게 생김
        - 여러 개의 변수를 한 번에 선언해 다룰 수 있는 자료형
            - [ ] 사용
            - 내부 값을 , 쉼표로 구분해서 씀
            - 내부 값을 요소 element 라고 함

        1. 배열 선언
            -let 변수/상수명 = [요소, 요소, 요소]
                - 요소란 ??? 배열내 들어간 자료 (1.숫자 2.불 3.문자열 4. 배열 5.함수 6.객체)
        2. 배열 요소에 접근
            - 인덱스 란?? 배열내 요소들이 저장된 순서번호
                0부터 시작 ( 주의할 점 length/size 1부터 시작 )
            - 형태
                변수명[인덱스번호]

        3. 배열 요소 개수 확인
            배열.length

        4. 배열 뒷부분에 요소 추가하기
            배열.push( 마지막 인덱스 추가할 요소 );

            - 중간 삽입
            배열.splice(중간삽입할 요소의 인덱스위치, 0 , 추가할 요소의 값)

        5. 배열 요소 제거하기
            배열.splice(제거할 요소 의 인덱스부터, 제거할 요소의 개수)
                - 배열.splice(0) : 배열 요소 전체 삭제
            - 값을 이용한 삭제 : 배열.splice(indexof값, 1)

        6. 배열내 특정 값의 위치 찾기
            배열.indexof(값);
                - 배열내 동일한 값이 있으면 인덱스번호 반환, 없으면 -1

    변수 : 하나의 자료를 저장하는 메모리 공간
    상수 : 하나의 자료를 저장하는 메모리 공간 (수정 불가능)
    배열 : 여러가지 자료를 묶어서 하나의 자료 [ ] 로 만들어주는 문법   

    ["문자열".length-1] : 마지막 인덱스
*/
 // p.161

 const array = [273, 'String', true, function(){}, { }, [273,10]]
        // 가장 큰 쇼핑백 = [ 273, ['s','t','r','i','n','g'], true, 함수(){}, { 객체 } , 배열 ]
        // 가장 큰 쇼핑백 = [숫자자료형,     배열자료형    , 불자료형 ,  함수  , 객체 , 배열자료형 ]

        /* 자바는 배열은 함수, 객체등을 저장 못 함, 스크립트가 제약이 덜 함. */
        
 console.log(array); console.log(array[3]); console.log(array[5][0])/* =273 */

 // p.164
const todos = [ '우유 구매', '업무 메일 확인하기', '필라테스 수업']
console.log(todos); // 배열 호출 //

todos.push('저녁 식사 준비하기');   // 배열 내 요소 추가 
console.log(todos); // 배열 호출 //

todos[7] = '사과먹기'; // 의미없는 인덱스에 자료 대입
console.log(todos); // 배열 호출 //

// p.166
const itemsA = ['사과', '배', '바나나'];
console.log(itemsA);

itemsA.splice(2,1); // 2번 2인덱스로부터 1개 삭제
console.log(itemA);

//itemsA.splice(0); // 0번 인덱스부터 모두 삭제
//console.log(itemA);

// p.167
const itemsB = ['사과', '배', '바나나'];
const index = itemsB.indexOf('바나나');
console.log(index); //2
itemsB.splice (index,1); // 2번 인덱스부터 1개 삭제
console.log(itemsB); // 확인 ['사과' , '배']

// p.168
const itemsD = ['사과', '귤', '바나나', '오렌지']
itemsD.splice(1, 0, '양파'); // 1번 인덱스에 삭제를 하지않고 '양파'를 접합(splice)
console.log(itemD); //  대신에 1번 인덱스 뒤로 한칸씩 물러남. [p.165 그림 참고]

itemD.splice ( itemsD.length , 0, '수박'); // vs push() 동일






 


